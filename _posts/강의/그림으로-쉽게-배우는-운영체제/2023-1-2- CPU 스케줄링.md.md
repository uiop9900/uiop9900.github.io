---
title: CPU 스케줄링
date: 2023-1-2 17:18:00
categories: [강의, 그림으로-쉽게-배우는-운영체제]
tags: [운영체제]
---

## CPU스케줄링 개요
컴퓨터는 필수장치(CPU, 메모리)와 주변장치(하드디스크, 키보드, 마우스)로 이루어져있다.
프로그램 실행 -> 메모리에 프로세스가 올라감 -> 각 프로세스마다 하나 이상의 쓰레드가 존재 -> 쓰레드는 CPU를 차지하기 위해 운영체제의 명령을 기다리고 있음  

- CPU스케줄링: 운영체제가 모든 프로세스에 CPU를 할당, 해제 하는 것
- 운영체제가 스케줄링을 할때 고려해야하는 사항
	- 어떤 프로세스에게 할당할까?
	- 얼마의 시간동안 할당할까?

위의 2가지에 따라 컴퓨터 성능에 많은 영향을 미치며 오늘날에는 시분할 스케줄링으로 아주 빠르게 번갈아가면서 프로세스를 실행한다. 
- CPU Burst: CPU를 할당받아서 하는 작업
- I/O Burst: 입출력 작업

## 다중큐
준비상태(실행을 기다리는 프로세스)와 대기상태(입출력을 대기하는 프로세스)는 Queue 자료구조로 관리된다.
 - Queue 자료구조: 먼저 들어온게 먼저 처리되고 나중에 들어온게 나중에 처리된다(스택과 반대)
 - 스택: 먼저 들어온게 제일 나중에, 제일 나중에 들어온게 먼저 처리된다.
 
- 실행상태 -> 준비상태로 돌아갈때
	- 운영체제는 프로세스를 보고 우선순위에 따라 준비큐에 PCB를 넣는다.
	- CPU 스케줄러는 준비 큐에 있는 PCB 중에 하나를 골라 실행상태로 변환한다.
- 실행상태 -> 대기상태
	- 운영체제는 IO작업(하드디스크, 랜, 키보드 등)에 따라 PCB를 분류해 놓는다.
	- CPU 스케줄러는 준비 큐에 있는 PCB 중에 하나를 골라 실행상태로 변환한다.
	

## 스케줄링 목표
- 리소스 사용률
	- CPU 사용률을 높이거나 IO 디바이스의 사용률을 높인다.
- 오버헤드 최소화
	- 컨텍스트 스위칭 비용과 스케줄링 계산 비용을 최소화
- 공평성
	- 프로세스들이 공평하게 할당받아야 한다.
	- 어떤 프로그램인가에 따라 공평성이 달라지지만 (ex. 자율주행자동차에게는 자율주행프로그램에게 가장 많은 할당을 주는게 공평) 우리가 쓰는 프로그램은 다같이 할당하는게 공평하다.
- 처리량
	- 같은 시간내에 더 많은 처리를 할 수 있는 방법
- 대기시간
	- 요청과 실행 사이의 대기시간을 짧게 하는 걸 목표
- 응답시간
- 
위의 항목들에 다 초점을 맞추기는 어렵기때문에 기능에 따라 어디에 초점을 맞출지 고른다.
하지만 일반적인 유저의 경우에는 고루 초점을 맞추려고 한다.

## 스케줄링 알고리즘
### FIFO(First In First Out)
: 먼저 들어온 작업이 먼저 실행된다. 먼저 들어온 작업이 완전히 끝나야만 다음 작업이 실행된다.
- 단순하고 직관적이다.
- 먼저 들어온 프로세스가 끝나야 다음 프로세스가 실행되기때문에 프로세스의 길이와 상관없이 앞의 프로세스가 끝나길 기다려야한다.
	- IO 작업이 있다면, IO작업이 끝날때까지 기다려야함 -> CPU 사용률이 떨어진다.

스케줄링의 성능은 "평균대기시간"(프로세스 모두가 실행될 때까지 대기한 시간의 평균)으로 계산한다.
-> 프로세스의 순서만 바꿔도 성능처리가 나기때문에 FIFO는 현재는 일괄처리시스템에서 쓰인다.

### SJF(Shortest Job First)
: 짧은 작업을 먼저 실행한다.
- 프로세스의 종료시간은 예측하는게 불가능하다. (유저마음대로라 언제끝날지 계산할 수 없음)
- Burst Time이 긴 프로세스가 밀려서 아예 실행되지 않을수도 있다.
-> 현재 사용하지 않는다.

### RR(Round Robin)
프로세스에게 일정 시간을 할당하고 그 시간이 지나면 그 프로세스는 큐의 맨 뒤로 보내고 그 다음 프로세스를 실행한다.
- 타임 슬라이스( = 타임 퀀텀) : 프로세스에 할당하는 시간
FIFO와 비교해보았을때 성능시간이 비슷하다면 RR이 비효율적이다. RR은 프로세스가 변경되기 때문에 컨텍스트 스위칭 비용이 있어서 스위칭 시간이 추가된다.

- RR의 성능은 타임 슬라이스 시간에 따라서 성능에 차이가 있다.
	- 타임 슬라이스가 클 경우: FIFO와 동일해진다.
	- 타임 슬라이스가 너무 작을 경우: 프로세스가 동시에 실행되는 것처럼 보이지만 컨텍스트 스위칭 비용이 너무 커진다. (오버헤드가 너무 크다)
사용자가 느끼기에 프로세스들이 동시에 실행되는 것처럼 느끼면서 오버헤드가 적은 시간으로 설정해야한다.

### MLFQ(Multi Level Feedback Queue)
: RR의 업그레이드 버전
작은 크기의 타임 슬라이드는 CPU와 IO의 사용량을 높인다.
타임슬라이스보다 빠르게 처리되면 IO이고, 초과되어서 뻇기면 CPU 프로세스일 확률이 크다.
- 우선순위가 크면 타임슬라이스 크기가 작고
- 우선순위가 작으면 타임슬라이스 크기가 커진다.

한번 할당을 받아서 프로세스를 실행 한 후에 작업이 끝났는지 초과되어서 뺏겼는지에 따라 할당되는 타임슬라이스의 크기를 다르게 할당한다.





