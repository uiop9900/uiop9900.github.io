---
title: 가상 메모리 1 
date: 2023-1-13 17:18:00
categories: [강의, 그림으로-쉽게-배우는-운영체제]
tags: [운영체제]
---

## 개요
: 컴퓨터마다 메모리용량은 다르고, 프로그램이 필요로 하는 메모리만큼 컴퓨터가 가지고 있지않다면 프로그램을 실행하지 못한다. -> 가상메모리가 해결한다.

프로세스는 물리메모리의 어느 주소에서 실행될지 고민할 필요가 없다.
메모리 관리자에게 요청을 하면 메모리 관리자가 알아서 메모리에 할당해 주기 때문에 언제나 0x0 번지에서 실행된다고 생각하면 된다.

- 가상메모리의 크기는 물리메모리와 CPU의 bit에 따라 결정된다.

#### 하지만 그래도 메모리가 많이 필요한 경우, 어떻게 실행될까?

- 초과되는 프로세스들은 하드디스크의 스왑영역에 넣어두고 실제 처리가 필요할 경우, 물리메모리로 가지고 와서 실행한다.
- 동적주소변환(메모리나 스왑영역에 저장된다.) : 메모리 관리자는 물리메모리와 스왑영역을 합쳐서 프로세스가 사용하는 가상주소 물리주소로 변환한다. (메모리의 크기를 가상으로 크게 만들어 놓고, 우리가 말하는 주소에서 실질적으로 사용되는 물리주소로 변환한다.) 
- 동적주소변환을 하게 되면, 프로세스는 사용자의 데이터를 물리 메모리에 배치할 수 있다.
- 메모리관리자는 가변분할방식(세그멘테이션)과 고정분할방식(페이징)을 섞은 세그멘테이션-페이징 혼용기법을 사용한다.
- 메모리관리자는 가상주소와 물리주소를 1:1 매핑 테이블로 관리한다.

## 1) 배치정책 - 세그멘테이션
: 세그멘테이션 기법에서 프로그램은 각 영역(메인코드, 데이터, 힙영역, 스택)을 세그먼트로 구성한다.

#### Q: 그렇다면 메모리 관리자는 어떻게 사용자, 프로세스, CPU가 말하는 논리주소를 물리주소로 변환할까?

#### A1: 세그멘테이션 테이블를 통해 계산한다.
- Base Address: 
- Bound Address : 세그먼트의 크기


- 세그멘테이션 테이블

|세그먼트 번호|Base Address|Bound Address|
|------|---|---|
|0|1500|500|
|1|5200|1000|
|2|3900|1200|
|3|8900|600|


- 요청 과정

```
1) CPU가 논리주소로 요청한다. 
2) 메모리관리자는 몇 번째의 세그먼트인지 알아낸다. 
3) 메모리 관리자 안에 Segment Table Base Register로 물리 메모리 안 세그멘테이션 테이블을 찾음 
4) 몇 번 세그먼트 인지가 인덱스로 그 번호에 맞는 Base, Bound Address를 확인한다.
5) 요청받은 논리주소와 BoundAddress를 비교 
	5-1) 논리주소 <= Bound Addrress
		물리주소 = 논리주소 + Base Address
	5-2) 논리주소 > Bound Address
		메모리를 침범했다고 인지하고 프로세스 종료
```

<br>

## 2) 배치정책- 페이징
: 모든 페이지를 같은 크기로 나누어서 관리한다.
- 페이지 : 일정하게 나뉜 논리주소공간
- 프레임 : 일정하게 나뉜 물리주소공간

#### A2: 페이지 테이블를 통해 계산한다.

- 페이지 테이블

|인덱스|프레임|
|------|---|
|0|3|
|1|1|
|2|Invalid|
|...|...|


- 요청 과정

```
1) CPU가 논리주소로 요청 
2) 메모리 관리자가 몇 번 페이지인지와 오프셋을 계산
	2-1) 페이지 넘버 : 논리주소 / 페이지크기 (몫) -> 인덱스
	2-2) 오프셋 : 논리주소 % 페이지크기 (나머지)
	2-3) 인덱스로 프레임을 가지고 와서 오프셋 만큼 더한다.
3) 메모리 관리자 안에 Page Table Base Register로 물리메모리의 페이지 테이블을 찾음 
4) 페이지번호를 인덱스로 프레임 번호를 알아내고 오프셋을 이용해 물리주소로 변환한다. 
	4-1) 프레임이 Invalid 로 되어있으면 하드디스크의 스왑영역에 저장되어있는 상태이다.
```


- 상단의 요청 과정은 컨텍스트 스위칭이 일어나는 경우 프로세스에 맞게 변경된다. 컨텍스트 스위칭은 무겁다.


## 3) 배치정책 - 페이지드 세그멘테이션

- 세그멘테이션에서는 코드, 데이터, 스택, 힙을 다 하나의 세그먼트로 나눠서 관리하기때문에 다른 프로세스와 공유하기 편하고 각 영역에 대해 메모리 접근보호도 하기 쉽다.

### 메모리 접근권한
 : 메모리의 특정번지에 부여된 권한으로 읽기(Read), 쓰기(Write), 실행(Excute)로 3가지가 존재한다.
- 프로세스는 각 영역마다 접근 권한이 존재한다.
	- Code: 프로그램 그 자체, Read/Excute
	- data : 여러값들이 저장, Read/ Write(있을수도 없읈도) 
	- 스택/힙 : 읽기와 쓰기권한 존재
- 메모리 접근권한은 가상주소 -> 물리주소로 변환될때마다 일어난다.
- 위반시 에러발생

- 페이지드 세그멘테이션
	- 상단에서 세그멘티에션 테이블과 페이지 테이블을 합친다.

세그먼트 테이블에서 권한비트 컬럼이 추가되고, 기존의 Base Address -> 페이지 넘버, Bound Address -> 페이지의 개수로 명칭이 달라진뿐 실질적인 역할을 동일하다.

|세그먼트 번호|권한비트|페이지넘버|페이지 개수|
|------|---|---|---|
|0|RW|2|500|
|1|RE|0|1000|
|2|R|1|1200|
|3|RWE|n|600|


|인덱스|프레임|
|------|---|
|0|3|
|1|1|
|2|Invalid|
|3|...|


- 요청 과정
```
1) CPU가 논리주소로 접근 요청 
2) 몇 번 세그먼트 인지 확인 
3) 세그먼트의 번호로 인덱스를 따서 권한을 확인한다.
	3-1) 권한이 없을시, 프로세스 종료.
	3-2) 권한이 있다면, 페이지 넘버와 페이지 개수를 확인 
4) 페이지 넘버를 인덱스로 페이지 테이블의 프레임을 가지고 온다. 
5) 해당 프레임에 페이지 개수를 더해서 물리주소를 구한다.
6) 만약 물리메모리에 해당프레임이 없으면(Invalid) 이면 스왑영역에서 가지고 온다.
```

이 방법은 물리메모리에 접근하기 위해 메모리에 2번 접근해야한다. (테이블 2번 참조) -> 페이징과 페이지드 세그멘테이션 기법을 적절히 섞어서 사용한다.


