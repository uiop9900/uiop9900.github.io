---
title: 정리와 DIP
date: 2022-11-09 17:18:00
categories: [강의]
tags: [til, dip]
---

## 이제까지 배운 내용
- 객체 == 제공하는 기능
- 캡슐화:  외부영향을 최소화하기 위해 내부구현을 감춘다.
- 추상화: 공통된 기능을 interface로 빼서 상위클래스로 만든다. 구현시에는 그걸 상속받아서 구현한다. -> 상속을 하다보니 에러사항들이 생겨서 조립이 대안으로 도출됨
- 기능과 책임 분리 -> 적절히 분리하기
- 의존과 DI : 의존대상이 많을수록 변경될 확률이 높기때문에 의존대상이 적을 수록 좋다.

## DIP(Dependency Inversion Principle)
: 의존 역전 원칙
- 고수준 모듈(기능의 정책): 의미있는 단일 기능을 제공, 상위의 정책을 구현함 -> 학생의 프로필을 저장한다. 
- 저수준 모듈(하위기능의 구현): 고수준의 기능 구현을 위해 필요한 하위기능들을 실제로 구현한 것 -> STUDENT_NAME 테이블에 저장한다.

고수준에서 직접 저수준의 메소드를 가져다가 쓰면 저수준이 변경되었을때 고수준의 코드도 변경되어야 한다. -> 당연한 얘기 -> 고수준 모듈이 저수준 모듈의 구현에 의존하고 있음 -> 의존 역전 원칙(Dependency Inversion Principle)

고수준 입장에서 저수준 모듈을 추상화 -> 고수준에서 구현하다가 아래로 내려도 될거같으면 따로 뻬서 아래로 내리라는 이야기, 구현입장에서 추상화 하는게 아님
이렇게 빼기 시작하면 고수준 모듈의 변경을 최소화하면서 저수준의 변경 유연성이 올라갈 수 있음


처음부터 DIP 를 하기는 쉽지않다 -> 업무에 대한 이해도에 따라 저수준 모듈을 인지하고 추상화를 시도한다. 

주요 비즈니스 로직 : 고수준
실행, 구현 로직: 저수준
- 의존한다:  A클래스가 실행하는 것에 있어서 B클래스의 메소드가 필요하다 -> A는 B에 의존한다.
```java
class A {
	public int head() {...}
}

class B {
	
	public int face(head h) {...}

	public A face() {...}

}
```
위에서  class A 는 class B의 존재도 모르고 B가 바뀐다고 하여도, 변경사항이 없다.
class B는 class A가 변경될경우, 로직이 변경되어야 한다 
-> class B가 A를 의존하고 있다. 


다음: TDD, 함수형 프로그래밍 기초, 설계패턴

출처: 최범균, "객체 지향 프로그래밍 입문", 인프런