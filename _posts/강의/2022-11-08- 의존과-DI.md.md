---
title: 의존과 DI
date: 2022-11-08 17:18:00
categories: [강의]
tags: [til, 의존]
---

# 의존
기능구현을 위해 다른 구성요소들을 사용하는 것을 의미한다.
객체생성, 메소드 호출, 데이터를 사용하는것 모두를 의존한다고 표현한다.

의존하고 있다면 의존하는 대상이 변경될 경우, 그 변경이 전파될 가능성이 크다.
(기존에 파라미터 3개 받던 메소드를 호출 -> 파라미터 2개로 변경 -> 호출했던 메소드도 변경)

그래서 순환의존이 위험하다.
- 순환의존: A -> B -> C -> A 서로 꼬리를 맞물며 의존하고 있는 상태.

최대한 순환의존이 발생하지 않도록 해야한다.

## 의존대상이 많을 경우?
- 한 클래스에 기능들이 많을 경우 -> 그 안에 의존하는 것들이 많아진다 -> 그럴수록 변동성이 커지고 순환의존의 가능성이 커진다. -> 기능별로 클래스를 쪼갠다. 
- 여러개의 의존 대상을 단일 기능으로 묶어서 대상을 줄인다. 


의존하는 대상을 객체로 생성한다,.
의존하는 로직이 변경되면 객체가 변경된다. 
의미가 없음

의존 대상 객체를 직접 생성하지 않는 방법?
- 팩토리, 빌더
- 의존주입(DI)
- 서비스 로케이터

### 의존주입(DI)
직접 생성하는게 아니라 생성자나 메소드를 이용해서 주입한다. 초기화되는 코드에서 사용한다.
왜 굳이 DI를 사용하는가?
받는 대상이 변경되어도 의존대상만 수정해도 그 의존을 사용하는 메소드는 변경하지 않아도 된다.

대역객체를 사용해서 테스트 가능 -> db가 없더라도 임의로 값을 넣고 그 값에 대해 테스트를 할수있다.

DI습관이 불러오는 장점들 찾아보기


출처: 최범균, "객체 지향 프로그래밍 입문", 인프런

---


객체는 내부의 데이터가 아니라 제공하는 기능으로 정의 
캡슐화: 내부구현을 감춘다. 외부영향을 최소화하기 위해
추상화: 공통된 기능을 interface로 빼서 상위클래스로 만든다. 구현시에는 그걸 상속받아서 구현한다. -> 상속을 하다보니 에러사항들이 생겨서 조립이 대안으로 도출됨

기능과 책임 분리 -> 적절히 분리하기
의존과 DI : 의존대상이 적을수록 좋음 


다음: TDD, 함수형 프로그래밍 기초, 설계패턴

부록:DIP
고수준 모듈(기능의 정책): 의미있는 단일 기능을 제공, 상위의 정책을 구현함 -> 학생의 프로필을 저장한다. 
저수준 모듈(하위기능의 구현): 고수준의 기능 구현을 위해 필요한 하위기능들을 실제로 구현한 것 -> STUDENT_NAME 테이블에 저장한다.

고수준에서 직접 저수준의 메소드를 가져다가 쓰면 저수준이 변경되었을때 고수준의 코드도 변경되어야 한다. -> 당연한 얘기 -> 고수준 모듈이 저수준 모듈의 구현에 의존하고 있음 -> 의존 역전 원칙(Dependency Inversion Principle)

고수준 입장에서 저수준 모듈을 추상화 -> 고수준에서 구현하다가 아래로 내려도 될거같으면 따로 뻬서 아래로 내리라는 이야기, 구현입장에서 추상화 하는게 아님
이렇게 빼기 시작하면 고수준 모듈의 변경을 최소화하면서 저수준의 변경 유연성이 올라갈 수 있음


처음부터 DIP 를 하기는 쉽지않다 -> 업무에 대한 이해도에 따라 저수준 모듈을 인지하고 추상화를 시도한다. 





