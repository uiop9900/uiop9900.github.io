---
title: 분산시스템에서 데이터를 전달하는 효과적인 방법
date: 2022-11-24 17:18:00
categories: [Forum, NHN FORWARD 2022]
tags: [til, backend]
---

분산시스템: 목표를 달성하기위해서 여러대의 컴퓨터 리소스를 사용하는 시스템(최소 2개 이상)

전달방법 2가지
- remote API
	- server- client 구조
		- 데이터 처리는 양쪽에서 가능 
- MessageQue
	- pulisher - consumer
		- consumer가 데이터 조작 
	- 배치, 비동기 작업에서 사용
	- 비교적 복잡한 개발

----

### [ 대전제 ]
모든 컴포넌트들은 네트워크로 연결되어있다.
하지만 네트워크는 신뢰할 수 없는 매체이다.
- 패킷손실
- 네트워크 지연
- 네트워크 다운
-> 데이터 유실을 항상 유의해야 한다.

### 효율적으로 전달하는 방법
1. 최대 한번 전달(At most once delivery)
	1. producer는 최대 한 번만 전송(fire and forget)
	2. consumer는 최대 한 번만 메세지 수신
		1. 여러 이유들로 못 받을 수 있다.
- 장점:간단 구조, 간단 개발 / 단점: 메세지 유실

2. 최소 한번 전달(at least once delivery)
	1. producer는 최소 한 번 전송
	2. consumer는 최소 한 번 이상 수신
- 장점:  메세지 발송 보장 / 단점: 멱등성이 떨어짐(여러번 메세지를 받더라도 결과가 같아야 한다.)

3. 정확하게 한번(Exactly once delivery)
-  장점 : 누락 중복 없음 / 단점: 제일 어려움

---

### RDB를 사용하는 애플리케이션에서 전달하는 방법
서비스별 데이터베이스 패턴(서비스마다 데이터베이스가 존재한다.)

정상흐름: restAPI -> 데이터 전달 -> DB 트랜잭션 -> commit
에러발생: restAPI -> 데이터 전달 -> DB 트랜잭션 -> 에러 -> DB Rollback  -> API는 이미 호출됨

에러가 발생했을시 DB는 roll back 되지만 API는 이미 호출되었다.
즉, 원본데이터가 없는데 이벤트가 발생한다. -> 불일치 발생

```java
@Transactional
public void function() {
	memberRespotiory.save(); // 실패 시, Roll-back
	applicationEventPublisher.publishEvent(); // Roll-back 안된다.
	userMemberRepository.save(); // 실패 시, Roll-back
}

```

- ApplicationEventPublisher() : Spring 에서 
- 옵저버 형태의 구현체

- 여기서 옵저버 형태란?
	- 객체의 상태 변화를 관찰하는 관찰자들(== 옵저버), 옵저버 목록을 객체에 등록하여 상태변화가 있을때마다 메소드 등을 통해 객체가 직접 목록에 각 옵저버에게 통지하도록 하는 디자인 패턴이다.
	- -> 주로 분산이벤트 핸들링 시스템을 구현하는데 사용.
	- 

```java
@Retriable -> 실패시 retry -> 
@TransactionalEventListner
```


TransactionalEventListner: 이벤트의 실질적인 발생을 트랙잭션 종료를 기준으로 삼는다.


Transactianal Outbox

polling 
메세지 큐처럼 테이블을 만들어야 한다.

하나의 tanx 안에 eventReposiroty에도 event를 저장한다.
이벤트가 잘 실행되면 상태를 바꾼다.

polling, publisher 로 지연처리가 될 수 있다.

---

### rabbitMQ
AMQP 를 구현한 메시지 브로커
ACK 라는 메세지 응답처리 기능이 있음.

이건 모릅니다. 패스하겠습니다..



---

### Kafka 를 사용한 방법
```java
kafkaTemplate.send()
future,addCallback
```




